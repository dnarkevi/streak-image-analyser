# Creative Commons Attribution (CC-BY) 4.0 2023 Domantas Narkeviƒçius. Some rights reserved.
#
# For help or bug reports, please contact me via Github: https://github.com/dnarkevi/
#
# This program can be used or modified in any way you want, but
# it goes under the terms of the Creative Commons Attribution 4.0, 
# which means you must reference the author. See https://creativecommons.org/licenses
# for more information.

icon = b'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'
import os
import traceback
import numpy as np
from numpy.polynomial import Polynomial
from scipy import optimize, signal, interpolate
import PySimpleGUI as sg
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.widgets import SpanSelector
from matplotlib.colors import Normalize
matplotlib.use("TkAgg")
sg.theme("Gray Gray Gray")

#%%Initial
span1_x = span2_x = span1_y = span2_y = ''
fr_1 = 0
fr_2 = "1E6"
count = 2000

time_1 = 0
time_2 = 100000
width = 1
shift = 10
background = 0
t1 = 10
A1 = 1e-2
t2 = 100
A2 = 1e-2
t3 = 400
A3 = 1e-2

def wincl(*keys, **kwargs):
    """Clears PySimpleGUI widget."""
    if isinstance(keys[0], (list, tuple)):
        keys, = keys
    for k in keys:
        window[k].update('', **kwargs)
        
def bind(keys, append_key, enable = True):
    """(Un)Binds Tkinter event to an elements (widgets)."""
    if enable:
        for k in keys:
            window[k].bind('<Return>', append_key)
    else:
        for k in keys:
            window[k].unbind('<Return>')
    
def disable_elem(*keys, arg = None):
    """Disbales PySimpleGUI widget. Transfers one argument."""
    if isinstance(keys[0], (list, tuple)):
        keys, = keys
    if arg == None:
        for k in keys:
            window[k].update(disabled = True)
    else:
        for k in keys:
            window[k].update(arg, disabled = True)
         
def enable_elem(*keys, arg = None):
    """Enables PySimpleGUI widget. Transfers one argument."""
    if isinstance(keys[0], (list, tuple)):
        keys, = keys
    if arg == None:
        for k in keys:
            window[k].update(disabled = False)
    else:
        for k in keys:
            window[k].update(arg, disabled = False)

def ars(arr, decimals = 2):
    """Rounds numpy.ndarray and changes its dtype to str."""
    if type(arr) == list and type(arr[0]) == np.ndarray: 
        arr = np.column_stack(arr)
    return arr.round(decimals).astype(str)

def ueven(val):
    """Returns odd number if it is even."""
    if val % 2 == 0:
        return val - 1 
    else:
        return val
    
def prep_input(key, min_val = -np.inf, max_val = np.inf, integer = False, update = True):
    """Reads input value from PySimpleGUI widget.
    Converts to number if possible. 
    Bounds limit return value.
    Input widget is updated by default.
    """
    if integer:
        try: val = int(float(values[key]))
        except: val = 0        
    else:
        try: val = float(values[key])
        except: val = 0
    if val < min_val: val = min_val
    if val > max_val: val = max_val   
    if update:
        window[key].update(val)
    return val

def find_nearest(array, value):
    """Finds the closest element index to the given value in the array."""
    array = np.asarray(array)
    idx = (np.abs(array - value)).argmin()
    return idx

def gauss(x, sig, mu):
    """To one normalised gauss function."""
    vals = np.exp(-np.power(x - mu, 2)/(2*np.power(sig, 2)))
    return vals/max(vals)*max(decay)

def func_mono(param, x):
    w, s, b, t1, a1 = param
    c1 = a1*np.exp(-x/t1)
    exc = gauss(x, w, s)
    return signal.fftconvolve(c1, exc) + b

def func_di(param, x):
    w, s, b, t1, a1, t2, a2  = param
    c1 = a1*np.exp(-x/t1)
    c2 = a2*np.exp(-x/t2)
    exc = gauss(x, w, s)
    return signal.fftconvolve(c1 + c2, exc) + b

def func_tri(param, x):
    w, s, b, t1, a1, t2, a2, t3, a3 = param
    c1 = a1*np.exp(-x/t1)
    c2 = a2*np.exp(-x/t2)
    c3 = a3*np.exp(-x/t3)
    exc = gauss(x, w, s)
    return signal.fftconvolve(c1 + c2 + c3, exc) + b

def residual(param):
    """Calculates residuals for given decay and predetermined model function."""
    return (func(param, time)[tr_1:tr_2] - decay[tr_1:tr_2]) / decay[tr_1:tr_2]**0.5

class Toolbar(NavigationToolbar2Tk):
    """Displays only selected interactive elements."""
    toolitems = [NavigationToolbar2Tk.toolitems[c] for c in [0, 4, 5]]
    def set_message(self, msg):
        pass
#     #Vertical direction.
#     def _Button(self, text, image_file, toggle, command):
#         b = super()._Button(text, image_file, toggle, command)
#         b.pack(side=tk.TOP) # re-pack button in vertical direction
#         return b

class Toolbar_w_msg(NavigationToolbar2Tk):
    """Displays only selected interactive elements and coordinates."""
    toolitems = [NavigationToolbar2Tk.toolitems[c] for c in [0, 4, 5]]

class Fig:
    """Responsible for plot manipulation in window."""
    def __init__(self, size, key, toolbar_key = None, msg = False, row = 1, **kwargs):
        """Creates matplotlib figure and axes. Draws them into canvas widget."""
        DPI = 65
        fig = Figure(dpi = DPI, figsize = (size*1.5/DPI, size/DPI), facecolor = '#F0F0F0', constrained_layout = True)
        if row == 1: #Axes names are managed by the row count.
            self.ax = fig.subplots()
        else: 
            axes = fig.subplots(row, 1, **kwargs)
            for c in range(row): 
                setattr(self, 'ax' + str(c+1), axes[c])
        self.fig = fig
        figure_canvas_agg = FigureCanvasTkAgg(fig, window[key].TKCanvas)
        figure_canvas_agg.draw()
        if toolbar_key is not None and not msg:
            self.tb = Toolbar(figure_canvas_agg, window[toolbar_key].TKCanvas)
            self.tb.update()
        elif toolbar_key is not None and msg:
            self.tb = Toolbar_w_msg(figure_canvas_agg, window[toolbar_key].TKCanvas)
            self.tb.update()
        figure_canvas_agg.get_tk_widget().pack(side = 'right', fill = 'both', expand = 1)
    def clp(self):
        """Clears lines, scatter, ledend and toolbar zoom memory. Keeps figure and axes."""
        if hasattr(self, 'tb'): self.tb.update()
        for ax_attr in self.__dict__.keys():
            if ax_attr != 'fig':
                axes = getattr(self, ax_attr)
                axes.lines.clear()
                axes.collections.clear()
                axes.legend('')
                axes.get_legend().remove()
            else:
                break
        self.fig.canvas.draw()
    def disp(self, *args, **kwargs):
        """Creates image and draws it."""
        if hasattr(self, 'image'): self.image.remove()
        self.image = self.ax.imshow(*args, **kwargs)
        self.fig.canvas.draw()
    def span(self, do_span = False, direction = None):
        """Enables/disables span selector widget."""
        if do_span:
            self.SpSc = SpanSelector(self.ax, globals()[direction + '_callback'], direction, useblit = True)
        elif not do_span and hasattr(self, 'SpSc'):
            delattr(self, 'SpSc')
            
def horizontal_callback(x1, x2):
    """Used by span seletor. Returns values to global. Updates text widgets."""
    global span1_x, span2_x
    span1_x, span2_x = sorted([x1, x2])
    window['-CUT-'].update("%.1f - %.1fnm" % (span1_x, span2_x))
    enable_elem('-PLOT-')

def vertical_callback(y1, y2):
    """Used by span seletor. Returns values to global. Updates text widgets."""
    global span1_y, span2_y
    span1_y, span2_y = sorted([y1, y2])
    window['-CUT-'].update("%.1f - %.1f" % (span1_y, span2_y) + time_unit)
    enable_elem('-PLOT-')
#%%1Q
first_quarter = [
    [
        sg.T("Original Image size: "), sg.T('', key = '-PIX-')
    ],
    [
        sg.T("Cut frames from:"), sg.In(fr_1, (6, None), key = '-IN_FRAME1-'),
        sg.T("To:"), sg.In(fr_2, (6, None), pad = (5, 0), key = '-IN_FRAME2-'),
    ],
    [
        sg.T("Number of frames to combine per stack: "), sg.In(count, key = '-IN_COUNT-')
    ],
    [
        sg.T("Total count of partly merged images: "), sg.T(key = '-TOTCOUNT-')
    ],
    [
        sg.Checkbox("Jitter corr.", True, disabled = True, key = '-JITT_CORR-'),
        sg.Checkbox("Curve corr.", True, disabled = True, key = '-CURV_CORR-')
    ],
    [
        sg.Radio("Original image:", "show", disabled = True, enable_events = True, key = '-RS1-'),
        sg.Radio("Image w/ time scale correction:", "show", True, True, enable_events = True, key = '-RS2-')
    ],
    [
        sg.Canvas(size = (1.5*100, 100), key = '-CANVAS1-')
    ]
]

second_quarter = [
    [
        sg.Column([[sg.Radio("Vertical ROI:", "ROI_sel", True, True, enable_events = True, key = '-RR1-')],
                  [sg.Radio("Horizontal ROI:", "ROI_sel", disabled = True, enable_events = True, key = '-RR2-')]]),
        sg.Column([[sg.Checkbox("All", disabled = True, enable_events = True, key = '-CA1-')],
                  [sg.Checkbox("All", disabled = True, enable_events = True, key = '-CA2-')]]),
        sg.Canvas(pad = (20, 0), key = '-CANVAS2BAR-')   
    ],
    [
        sg.Canvas(size = (1.5*247, 246), key = '-CANVAS2-'),
        sg.Column([[sg.Column([[sg.T("LUT")],
                               [sg.Slider((0.01, 1), 1, 0.01, disable_number_display = True, pad = ((2, 0), 0),
                                          enable_events = True, key = '-LUT-')]], pad = (10, 0))]])
    ],
    [
        sg.In(enable_events = True, visible = False, key = '-EXP_IMG-'),
        sg.FileSaveAs("Export Image", file_types = (('TXT file', '*.txt'), ('ALL Files', '*.*')), pad = (5, 5)),
        sg.T('', (15, None), justification = 'right', pad = ((0, 5), 0), key = '-CUT-'),
        sg.Button("Plot", disabled = True, pad = (5, 5), key = '-PLOT-')
        
    ]
]

third_quarter = [
    [
        sg.Checkbox("Normalize", disabled = True, enable_events = True, key = '-NORM_SPECTRA-'),
        sg.Combo('', s = (14, None), readonly = True,  key = '-SEL_SPECTRUM-'),
        sg.Button("Delete", disabled = True, enable_events = True, pad = (5, 5), key = '-DEL_SPECTRUM-'),
        sg.Canvas(key = '-CANVAS3BAR-')
    ],
    [
        sg.Checkbox("Divide by pixels", disabled = True, enable_events = True, key = '-PIX_SPECTRA-')
    ],
    [
        sg.Canvas(size = (1.5*247, 246), key = '-CANVAS3-')
    ],
    [
        sg.In(enable_events = True, visible = False, key = '-EXP_SPECTRA-'),
        sg.FileSaveAs("Export All", file_types = (('TXT file', '*.txt'), ('ALL Files', '*.*')), pad = (5, 5))       
    ]
]

fourth_quarter = [
    [
        sg.Checkbox("Normalize", disabled = True, enable_events = True, key = '-NORM_DECAYS-'),
        sg.Combo('', s = (14, None), readonly = True, key = '-SEL_DECAY-'),
        sg.Button("Delete", disabled = True, enable_events = True, pad = (5, 5), key = '-DEL_DECAY-'),
        sg.Canvas(key = '-CANVAS4BAR-')
    ],
    [
        sg.Checkbox("Log scale", True, enable_events = True, key = '-LOG_DEC-'),
        sg.T("Add (+/-):", pad = ((10, 0), 0)),
        sg.In(0, pad = (5, 0), key = '-Y_MOD-'),
        sg.T("Shift by:"),
        sg.In(0, pad = (5, 0), key = '-X_MOD-'),
        sg.Button("Apply", disabled = True, key = '-APPLY_MOD-')
    ],
    [
        sg.Canvas(size = (1.5*247, 246), key = '-CANVAS4-')
    ],
    [
        sg.In(enable_events = True, visible = False, key = '-EXP_DEC-'),
        sg.FileSaveAs("Export All", file_types = (('TXT file', '*.txt'), ('ALL Files', '*.*')), pad = (5, 5)),
        sg.Button("Send to Fit", disabled = True, enable_events = True, pad = (5, 5), key = '-TO_FIT-')
        
    ]
]
#%%1stColumn
first_column = [
    [
        sg.T("File name:"),
        sg.T(s = (60, None), key = '-FILE_LOC-'),
        sg.In(enable_events = True, visible = False, key = '-OPEN_FILE-'),
        sg.FileBrowse(button_text = "Load file",
                      file_types = (('DPC image', '*.dpc'), ('ALL Files', '*.*')), pad = (5, 5)),
        sg.Button("Update", disabled = True, pad = (5, 5), key = '-UPDATE-'),
        sg.T('', s = (10, None), key = '-CORR_MSG-')
    ],
    [
        sg.Column(first_quarter),
        sg.VSeparator(pad = (5, 2)),
        sg.Column(second_quarter)
    ],
    [
        sg.HSeparator(pad = (0, (2, 5)))
    ],
    [
        sg.Column(third_quarter),
        sg.VSeparator(pad = ((10, 5), 2)),
        sg.Column(fourth_quarter)
    ]
]

initial_column = [
    [
        sg.T("Initial parameters:")
    ],
    [
        sg.T("(Select checkbox to fix the value.)")
    ],
    [
        sg.Column([[sg.T("Pulse width")], 
                   [sg.T("Pulse position")], 
                   [sg.T("Background")]]),
        sg.Column([[sg.In(width, key = '-IN_W-'),
                    sg.Checkbox('', pad = (2, 0), key = '-FIX_W-')],
                   [sg.In(shift, key = '-IN_S-'),
                    sg.Checkbox('', pad = (2, 0), key = '-FIX_S-')],
                   [sg.In(background, key = '-IN_B-'),
                    sg.Checkbox('', pad = (2, 0), key = '-FIX_B-')]])
    ],
    [
        sg.T("œÑ1 =", pad = (2, 0)), sg.In(t1, key = '-IN_T1-'),
        sg.Checkbox('', key = '-FIX_T1-'),
        sg.T("A1 =", pad = (2, 0)), sg.In(A1, key = '-IN_A1-'),
        sg.Checkbox('', key = '-FIX_A1-')
    ],
    [
        sg.T("œÑ2 =", pad = (2, 0)), sg.In(t2, key = '-IN_T2-'),
        sg.Checkbox('', key = '-FIX_T2-'),
        sg.T("A2 =", pad = (2, 0)), sg.In(A2, key = '-IN_A2-'),
        sg.Checkbox('', key = '-FIX_A2-')
    ],
    [
        sg.T("œÑ3 =", pad = (2, 0)), sg.In(t3, disabled = True, key = '-IN_T3-'),
        sg.Checkbox('', disabled = True, key = '-FIX_T3-'),
        sg.T("A3 =", pad = (2, 0)), sg.In(A3, disabled = True, key = '-IN_A3-'),
        sg.Checkbox('', disabled = True, key = '-FIX_A3-')
    ] 
]

result_column = [
    [
        sg.T("Result:")
    ],
    [
        sg.T("Chi^2 ="), sg.T(key = '-OUT_CHI-')
    ],
    [
        sg.Column([[sg.T("Pulse width")], 
                   [sg.T("Pulse position")], 
                   [sg.T("Background")]]),
        sg.Column([[sg.T(key = '-OUT_W-')],
                   [sg.T(key = '-OUT_S-')],
                   [sg.T(key = '-OUT_B-')]])
    ],
    [
        sg.Column([[sg.T("œÑ1 ="), sg.T(s = (5, None), key = '-OUT_T1-')], 
                   [sg.T("œÑ2 ="), sg.T(s = (5, None), key = '-OUT_T2-')], 
                   [sg.T("œÑ3 ="), sg.T(s = (5, None), key = '-OUT_T3-')]]),
        sg.Column([[sg.T("A1 ="), sg.T(s = (7, None), key = '-OUT_A1-')],
                   [sg.T("A2 ="), sg.T(s = (7, None), key = '-OUT_A2-')],
                   [sg.T("A3 ="), sg.T(s = (7, None), key = '-OUT_A3-')]]),
        sg.Column([[sg.T("A1% ="), sg.T(s = (7, None), key = '-OUT_A1%-')],
                   [sg.T("A2% ="), sg.T(s = (7, None), key = '-OUT_A2%-')],
                   [sg.T("A3% ="), sg.T(s = (7, None), key = '-OUT_A3%-')]])
    ],
    [
        sg.Column([[sg.T("œÑA ="), sg.T(s = (5, None), key = '-OUT_TA-')],
                   [sg.T("œÑI ="), sg.T(s = (5, None), key = '-OUT_TI-')]])
    ]    
]
#%%2ndColumn
second_column = [
    [
        sg.T("Cut time from:"), sg.In(time_1, key = '-IN_TIME1-'),
        sg.T("To:"), sg.In(time_2, pad = (5, 0), key = '-IN_TIME2-'),
        sg.Canvas(pad = (5, 0), key = '-CANVAS5BAR-')
    ],
    [
        sg.Canvas(size = (1.5*247, 246), key = '-CANVAS5-')
    ],
    [
        sg.Radio("Mono", "exp", enable_events = True, key = '-R1-'),
        sg.Radio("Di", "exp", default = True, enable_events = True, key = '-R2-'),
        sg.Radio("Tri", "exp", enable_events = True, key = '-R3-')
    ],
    [
        sg.Column(initial_column),
        sg.VSeparator(pad = ((1, 5), 2)),
        sg.Column(result_column)
    ],
    [
        sg.Button("Fit!", disabled = True, pad = (5, 5), key = '-FIT-'),
        sg.In(enable_events = True, visible = False, key = '-EXP_FIT-'),
        sg.FileSaveAs("Export Param", file_types = (('TXT file', '*.txt'), ('ALL Files', '*.*')), pad = (5, 5))
    ],
    [
        sg.In(enable_events = True, visible = False, key = '-EXP_MASTER-'),
        sg.FolderBrowse("Master Export", pad = (5, 5)) 
    ],
    [
        sg.T("Fit message:"),
        sg.T('', key = '-FIT_MSG-')
    ]
]

layout = [
    [
        sg.Column(first_column),
        sg.VSeparator(pad = ((10, 5), 2)),
        sg.Column(second_column),
    ]
]

update_events = ('-IN_FRAME1-', '-IN_FRAME2-', '-IN_COUNT-')
apply_events = ('-X_MOD-', '-Y_MOD-')
fit_events = ('-R1-', '-R2-', '-R3-', '-IN_TIME1-', '-IN_TIME2-', '-IN_W-', '-IN_S-', '-IN_B-', 
              '-IN_T1-', '-IN_A1-', '-IN_T2-', '-IN_A2-', '-IN_T3-', '-IN_A3-')
result_keys = ( '-OUT_CHI-', '-OUT_TA-', '-OUT_TI-', '-OUT_W-', '-OUT_S-', '-OUT_B-', '-OUT_T1-',
               '-OUT_A1-', '-OUT_A1%-', '-OUT_T2-', '-OUT_A2-', '-OUT_A2%-', '-OUT_T3-', '-OUT_A3-', '-OUT_A3%-')
fix_keys = ('-FIX_W-', '-FIX_S-', '-FIX_B-', '-FIX_T1-', '-FIX_A1-', '-FIX_T2-', '-FIX_A2-', '-FIX_T3-', '-FIX_A3-')
exp_names = {'-EXP_IMG-':' image', '-EXP_SPECTRA-':' spectra', '-EXP_DEC-':' decay', '-EXP_FIT-':' fit'}

window = sg.Window("Streak camera image data analyser", layout, (5, None), element_padding = (0, 0), location = (0, 0),
                   margins = (4, 0), finalize = True, icon = icon)


#%%figs
fig1 = Fig(200, '-CANVAS1-')
fig1.ax.set(xlabel = "Wavelength", ylabel = "Time")

fig2 = Fig(250, '-CANVAS2-', '-CANVAS2BAR-', msg = True)
fig2.ax.set(xlabel = "Wavelength", ylabel = "Time", title = "Final Image. Select area to analyse.")

fig3 = Fig(250, '-CANVAS3-', '-CANVAS3BAR-')
fig3.ax.set(xlabel = "Wavelength", xmargin = 0, ylabel = "Counts", title = "Intensity spectra")

fig4 = Fig(250, '-CANVAS4-', '-CANVAS4BAR-')
fig4.ax.set(xlabel = "Time", xmargin = 0, ylabel = "Counts", title = "Decays", yscale = 'log')

fig5 = Fig(250, '-CANVAS5-', '-CANVAS5BAR-', row = 2, gridspec_kw = {'height_ratios': [3, 1]})
fig5.ax1.set(ylabel = "Counts", yscale = 'log')
fig5.ax2.set(xlabel = "Time" , ylabel = "Residual")  

event_history = []
# Run the Event Loop
try:
    while True:
        event, values = window.read()
        event_history.append(event)
        if event == sg.WIN_CLOSED:
            break
        
        #Identifying Tkinter event triggger.
        if type(event) == str: 
            event = event.split('-¬¢')[-1]
            
        if event == '-OPEN_FILE-':
            try:
                #Opening and reading main data.
                file = values['-OPEN_FILE-']
                loc = np.fromfile(file, np.uint16)[1:4] ; loc[0] += 64 #Reads data starting location and image size in pixels.
                raw = np.roll(np.fromfile(file, np.uint16, offset = loc[0]), 2) #Reads all measurment data.
                delimiter = 2*np.where(np.fromfile(file, np.int32, offset = loc[0]) == -1)[0] + 2 #Reads location of each image.
                delimiter = np.insert(delimiter, 0, 0) #Taking into account new delimiter starting point.
                del_loc = np.tile(delimiter, [4, 1]) #Creates repeated delimiter values.
                for c in range(1, 4): 
                    del_loc[c] += c #Makes values increase in y-axis.
                del_loc = del_loc.flatten('F') 
                raw = np.delete(raw, del_loc[:-4]) #Deletes delimiter and time stamp values, leaving only coordinates.
                delimiter -= np.arange(0, len(delimiter)*4, 4) #New indexes for each image.
                tot_fr = len(delimiter) - 1
                
                #Reads calibration data.
                cal = np.fromfile(file, np.float32, offset = loc[0] - (loc[1] + loc[2])*4)[:loc[1] + loc[2]]
                xcal = np.flip(cal[:loc[1]]) #Flips to make axis more intuitive.
                xbd = [min(xcal), max(xcal)] #bd <-> bounds
                ycal = cal[loc[1]:]
                
                #Finds time unit of measurement.
                file_bin = open(file, 'br')
                file_bin.seek(64) #Location of metadata.
                mdata = file_bin.read(loc[0] - (loc[1] + loc[2])*4 - 64).decode('ascii') #Reads all metadata.
                mdata = mdata.replace('=', ',').split(',') 
                time_unit = mdata[mdata.index('ScalingYUnit') + 1].replace('"', '')
                
                #Reseting spectrum plot.
                all_spe = [] ; spe_names = [] ; spe_pix = []
                fig3.clp()
                
                window['-FILE_LOC-'].update(file)
                window['-PIX-'].update(str(loc[1]) + "x" + str(loc[2]) + "x" + str(tot_fr))
                window['-IN_FRAME1-'].update(0)
                window['-IN_FRAME2-'].update(tot_fr)
                enable_elem('-UPDATE-', '-JITT_CORR-', '-CURV_CORR-')
                bind(update_events, '-¬¢-UPDATE-')
                event = '-UPDATE-'
            except ValueError: 
                if values[event] != '':
                    sg.popup("File format is wrong.", title = "Error")
                    disable_elem('-UPDATE-', '-JITT_CORR-', '-CURV_CORR-')
                    bind(update_events, '-¬¢-UPDATE-', False)
            except FileNotFoundError:
                pass
            
        if event == '-UPDATE-':
            window['-CORR_MSG-'].update('Computing...')
            window.read(0)
            wincl('-CORR_MSG-')
            
            fr_2 = prep_input('-IN_FRAME2-', 1, tot_fr, True)
            fr_1 = prep_input('-IN_FRAME1-', 0, fr_2 - 1, True)
            count = prep_input('-IN_COUNT-', 1, fr_2 - fr_1, True)
            tot_img = int((fr_2 - fr_1)/count)
            
            #Initialising array of photons for analysis.
            try: 
                data = np.zeros((tot_img, loc[2], loc[1]), np.float32)
            except:
                MemoryError: sg.popup("Not enough memory. Increase number of frames to sum.", title = "Error")
                event = '-NONE-'
    #%%shift
        if event == '-UPDATE-':
            #Creates data array of photon count.
            for i in range(tot_img):
                a = raw[delimiter[i*count + fr_1]:delimiter[(i+1)*count + fr_1]] #All photon crdinates.
                np.add.at(data[i], (a[1::2], a[::2]), 1) #Adds photons by coordinates.
            a = raw[delimiter[(i+1)*count + fr_1]:fr_2] #Residual photons.
            np.add.at(data[i], (a[1::2], a[::2]), 1)
            data = np.flip(data, 2) #Flips for more intuitive displaying.
            
            #Calibration data is non-linear. Interpolation is used to make even spacing.
            ylin = np.linspace(min(ycal), max(ycal), loc[2], dtype = np.float32)
            for c in range(tot_img):
                data[c] = interpolate.interp1d(ycal, data[c], axis = 0)(ylin)
            nocorr_img = np.sum(data, 0)
            ncor_ybd = [ylin[-1], ylin[0]]
        
            #Shifting algorithm for creating uniform zero point (removing jitter).
            if values['-JITT_CORR-']:
                data_xsum = np.sum(data, 2)
                maxloc = np.argmax(data_xsum, 1)
                data_max = np.max(data_xsum, 1)
                data_min = np.empty(tot_img)
                for c in range(tot_img):
                    data_min[c] = np.min(data_xsum[c, :maxloc[c]]) 
                shift = np.argmax(data_xsum > np.vstack(data_max - data_min)*0.5, 1)
                if tot_img > 4:
                    shift = signal.savgol_filter(shift, ueven(tot_img), 3) #Smoothing.
                shift -= min(shift)
                shift = shift.astype(int)
                for c in range(tot_img): 
                    data[c] = np.roll(data[c], -shift[c], 0)
                enable_elem('-RS2-')
            else:
                shift = [0]
                window['-RS2-'].update(False, disabled = True)
                window['-RS1-'].update(True)
            
            #Updataing data properties.
            xlen = loc[1]
            ylen = loc[2] - max(shift)
            data = np.sum(data[:, :ylen], 0)
            jittcorr_img = np.copy(data)
            jitt_ybd = [ylin[ylen - 1], ylin[0]]
            
            #Shifting algorithm for removing curved zero points.
            if values['-CURV_CORR-']:
                data_ysum = np.sum(data, 0) 
                data_ysum -= np.average(np.sort(data_ysum)[:10])
                shift_arg, = np.where(150 < data_ysum) #Finding where inensity is enough for correction.
                maxloc = np.argmax(data, 0)
                maxloc[np.where(maxloc == 0)[0]] = 1
                data_max = np.max(data, 0)
                data_min = np.empty(xlen)
                for c in range(xlen):
                    data_min[c] = np.min(data[:maxloc[c]])
                shift = np.argmax(data > (data_max - data_min)*0.5, 0)
                #Fitting the curve with shift arguments where photon count is enough.
                if shift_arg.size > 8:
                    shift_par = Polynomial.fit(shift_arg, shift[shift_arg], deg = 4).convert().coef
                    shift = Polynomial(shift_par)(np.arange(xlen))        
                shift -= min(shift)
                shift = shift.astype(int)
                for c in range(xlen):
                    data[:, c] = np.roll(data[:, c], -shift[c], 0)
            else:
                shift = [0]
              
            #Updataing data properties.
            if 2*max(shift) < ylen:
                ylen -= max(shift)
            ylin = ylin[:ylen]
            img = data[:ylen]
            ybd = [ylin[-1], ylin[0]]
            
            #Resetting decay spectrum plot.
            all_dec = [] ; dec_names = [] ; dec_shift = []
            fig4.clp()
            fig5.clp()

            disable_elem('-DEL_DECAY-', '-TO_FIT-', '-FIT-')
            enable_elem('-RS1-', '-RR1-', '-RR2-', '-NORM_SPECTRA-', '-NORM_DECAYS-', '-PIX_SPECTRA-')
            wincl(result_keys)
            window['-IN_TIME2-'].update(10000)
            window['-TOTCOUNT-'].update(tot_img)
            bind(fit_events, '-¬¢-FIT-', False)
        
        if event in {'-RS1-', '-RS2-', '-UPDATE-'}:
            if values['-RS1-']:
                fig1.disp(nocorr_img, extent = xbd + ncor_ybd, aspect='auto')
            if values['-RS2-']:
                fig1.disp(jittcorr_img, extent = xbd + jitt_ybd, aspect='auto')
            fig2.ax.autoscale(True)
            fig2.tb.update()
            fig2.disp(img, extent = xbd + ybd, 
                              aspect='auto', norm = Normalize(None, values['-LUT-']*np.max(img)))
    #%%plot          
        if event == '-LUT-':
            fig2.ax.autoscale(False)
            fig2.disp(img, extent = xbd + ybd, 
                              aspect='auto', norm = Normalize(None, values['-LUT-']*np.max(img)))
            
        if event in {'-RR1-', '-RR2-', '-UPDATE-', '-CA1-', '-CA2-'}:
            #Allows to select region of interest.
            if values['-RR1-']:
                fig2.span(True, 'horizontal')
                enable_elem('-CA1-')
                disable_elem('-CA2-',  arg = False)
                wincl('-CUT-')
                disable_elem('-PLOT-', arg = "Plot decay")
            if values['-RR2-']:
                fig2.span(True, 'vertical')
                enable_elem('-CA2-')
                disable_elem('-CA1-', arg = False)
                wincl('-CUT-')
                disable_elem('-PLOT-', arg = "Plot spectrum")
            if values['-RR1-'] and values['-CA1-']:
                fig2.span(False)
                span1_x = min(xcal)
                span2_x = max(xcal)
                window['-CUT-'].update("%.1f - %.1fnm" %(span1_x, span2_x))
                enable_elem('-PLOT-')
            if values['-RR2-'] and values['-CA2-']:
                fig2.span(False)
                span1_y = ybd[1]
                span2_y = ybd[0]
                window['-CUT-'].update("%.1f - %.1f" %(span1_y, span2_y) + time_unit)
                enable_elem('-PLOT-')
                
        if event == '-PLOT-':
            #ROI image is processed to displayable data.
            if values['-RR1-']:
                x_cut1 = find_nearest(xcal, span1_x)
                x_cut2 = find_nearest(xcal, span2_x) + 1
                all_dec.append(np.sum(img[:, x_cut1:x_cut2], 1, np.float64))
                dec_names.append("%.1f - %.1fnm" %(span1_x, span2_x))
                dec_shift.append(0)
                window['-SEL_DECAY-'].update(values = dec_names, value = dec_names[-1])
                enable_elem('-DEL_DECAY-', '-TO_FIT-', '-APPLY_MOD-')
                bind(apply_events, '-¬¢-APPLY_MOD-')
            if values['-RR2-']:
                y_cut1 = find_nearest(ylin, span1_y)
                y_cut2 = find_nearest(ylin, span2_y) + 1
                all_spe.append(np.sum(img[y_cut1:y_cut2], 0, np.float64))
                spe_names.append("%.1f - %.1fps" %(span1_y, span2_y))
                spe_pix.append(y_cut2 - y_cut1)
                window['-SEL_SPECTRUM-'].update(values = spe_names, value = spe_names[-1])
                enable_elem('-DEL_SPECTRUM-')
        
        if event == '-DEL_SPECTRUM-':
            spe_idx = spe_names.index(values['-SEL_SPECTRUM-'])
            del all_spe[spe_idx] ; del spe_names[spe_idx] ; del spe_pix[spe_idx]
            if spe_names == []: 
                wincl('-SEL_SPECTRUM-')
                disable_elem('-DEL_SPECTRUM-')
            else:
                window['-SEL_SPECTRUM-'].update(values = spe_names, value = spe_names[-1])
                
        if event == '-DEL_DECAY-':
            dec_idx = dec_names.index(values['-SEL_DECAY-'])
            del all_dec[dec_idx] ; del dec_names[dec_idx] ; del dec_shift[dec_idx]
            if dec_names == []: 
                wincl('-SEL_DECAY-')
                disable_elem('-DEL_DECAY-', '-TO_FIT-', '-APPLY_MOD-')
                bind(apply_events, '-¬¢-APPLY_MOD-', False)
            else:
                window['-SEL_DECAY-'].update(values = dec_names, value = dec_names[-1])
                
        if (event == '-PLOT-' and values['-RR2-']) or event in {'-DEL_SPECTRUM-', '-NORM_SPECTRA-', '-PIX_SPECTRA-'}:
            fin_spe = []
            fig3.clp()
            #Spectra is modified, appended to list for export and drawn.
            if all_spe != []:
                for c in range(len(all_spe)):
                    temp_spe = np.copy(all_spe[c])
                    if values['-NORM_SPECTRA-']:
                        temp_spe /= max(temp_spe)
                    if values['-PIX_SPECTRA-']:
                        temp_spe /= spe_pix[c]
                    fin_spe.append(temp_spe)
                    fig3.ax.plot(xcal, fin_spe[c], label = spe_names[c], c = plt.cm.tab10(c))
                fig3.ax.relim()
                fig3.ax.autoscale(True)
                fig3.ax.legend(loc = "upper right")
            fig3.fig.canvas.draw()

        if event == '-LOG_DEC-':
            if values['-LOG_DEC-']:
                fig4.ax.set(yscale = 'log')
            else:
                fig4.ax.set(yscale = 'linear')
                
        if event == '-APPLY_MOD-':
            #Linear transformations.
            dec_idx = dec_names.index(values['-SEL_DECAY-'])
            dec_shift[dec_idx] += prep_input('-X_MOD-')
            all_dec[dec_idx] += prep_input('-Y_MOD-')
                
        if (event == '-PLOT-' and values['-RR1-']) or event in {'-DEL_DECAY-', '-NORM_DECAYS-', '-APPLY_MOD-', '-LOG_DEC-'}:
            fin_dec = []
            fig4.clp()
            #Decay is modified, appended to list for export and drawn.
            if all_dec != []:
                for c in range(len(all_dec)):
                    temp_dec = np.copy(all_dec[c])
                    if values['-NORM_DECAYS-']:
                        temp_dec /= max(temp_dec)
                        temp_dec *= np.max(all_dec)
                    fin_dec.append(temp_dec)
                    fig4.ax.plot(ylin + dec_shift[c], fin_dec[c], label = dec_names[c], c = plt.cm.tab10(c))
                fig4.ax.relim()
                fig4.ax.autoscale(True)
                fig4.ax.legend(loc = "upper right")
            fig4.fig.canvas.draw()
    #%%tofit        
        if event in {'-R1-', '-R2-', '-R3-'}:
            if values['-R1-']:
                disable_elem('-IN_T2-', '-IN_A2-', '-FIX_T2-', '-FIX_A2-',
                        '-IN_T3-', '-IN_A3-', '-FIX_T3-', '-FIX_A3-')
            if values['-R2-']:
                enable_elem('-IN_T2-', '-IN_A2-', '-FIX_T2-', '-FIX_A2-')
                disable_elem('-IN_T3-', '-IN_A3-', '-FIX_T3-', '-FIX_A3-')
            if values['-R3-']:
                enable_elem('-IN_T2-', '-IN_A2-', '-FIX_T2-', '-FIX_A2-',
                       '-IN_T3-', '-IN_A3-', '-FIX_T3-', '-FIX_A3-')    

        if event == '-TO_FIT-': 
            dec_idx = dec_names.index(values['-SEL_DECAY-'])
            decay = fin_dec[dec_idx].astype(np.float64)
            decay[np.where(decay < 1)[0]] = 1 
            time = ylin.astype(np.float64) #Also makes a copy.
            
            fig5.clp()
            fig5.ax1.set(ylim = (0.9*min(decay), 1.1*max(decay)), xlim = np.flip(ybd))
            fig5.ax2.set(xlabel = "Time, " + time_unit, xlim = np.flip(ybd))  
            fig5.ax1.scatter(time, decay, label = dec_names[dec_idx], s = 1, color = 'blue')
            fig5.ax1.legend(loc = "upper right", markerscale = 0, handletextpad = -1)
            fig5.fig.canvas.draw()

            enable_elem('-FIT-')
            bind(fit_events, '-¬¢-FIT-')
            wincl(result_keys)
            window['-IN_TIME1-'].update("%.1f" %(ybd[-1]))
            window['-IN_TIME2-'].update("%.1f" %(ybd[0]))
            
    #%%fit  
        if event == '-FIT-':
            #Prepares initial values and selects appropriate function for fitting.
            time_2 = prep_input('-IN_TIME2-', ylin[1], ylin[-1])
            tr_2 = find_nearest(ylin, time_2) + 1
            time_1 = prep_input('-IN_TIME1-', ylin[0], ylin[tr_2 - 1])
            tr_1 = find_nearest(ylin, time_1)
            window['-IN_TIME1-'].update("%.1f" %(ylin[tr_1]))
            window['-IN_TIME2-'].update("%.1f" %(ylin[tr_2 - 1]))
            
            param_min = [1e-3] + [-np.inf]*2 + [0]*6
            param_max = [np.inf]*9
            all_initial = [prep_input(fit_events[c+5], param_min[c]) for c in range(9)]
            for key in fix_keys:
                if values[key]:
                    f = fix_keys.index(key)
                    param_min[f] = all_initial[f] - np.finfo(np.float32).eps
                    param_max[f] = all_initial[f]
            if values['-R1-']:
                initial = all_initial[:5]
                func = func_mono
                pout = np.empty((3, 3))
                plen = 5
            elif values['-R2-']:
                initial = all_initial[:7]
                func = func_di
                pout = np.empty((4, 3))
                plen = 7
            else:
                initial = all_initial
                func = func_tri
                pout = np.empty((5, 3))
                plen = 9
                
            window['-FIT_MSG-'].update('Calculating...')
            window.read(100)
            try:
                res = optimize.least_squares(residual, x0 = initial, method = 'trf', bounds = (param_min[:plen], param_max[:plen]))
                window['-FIT_MSG-'].update(res.message)
            except ValueError:
                window['-FIT_MSG-'].update('Some parameters are too extreme!') 
                event = '-NONE-'
                
        if event == '-FIT-':
            #Assigning values of result parameters to empty matrix. Chaos...
            pout[1] = res.x[:3]
            a = np.reshape(res.x[3:], (-1, 2))
            pout[2:, :2] = a[a[:, 0].argsort()]
            pout[0, 0] = np.sum(res.fun**2)/(tr_2 - tr_1 - plen)
            pout[0, 1] = np.sum(pout[2:, 0]*pout[2:, 1])/np.sum(pout[2:, 1])
            pout[0, 2] = np.sum((pout[2:, 0]**2)*pout[2:, 1])/np.sum(pout[2:, 0]*pout[2:, 1])
            for c in range(2, len(pout)):
                pout[c, 2] = pout[c, 1] / np.sum(pout[2:, 1]) * 100
            for c in range(6):
                window[result_keys[c]].update("%.2f" %(pout.flatten()[c]))
            for c in range(2, len(pout)):
                window[result_keys[c*3]].update("%.2f" %(pout[c, 0]))
                window[result_keys[c*3+1]].update("%.2E" %(pout[c, 1]))
                window[result_keys[c*3+2]].update("%.2f" %(pout[c, 2])+"%")
            #Excitation function and decay fit.
            fig5.ax1.lines.clear()
            fig5.ax1.plot(time, gauss(ylin, pout[1, 0], pout[1, 1]), color = 'orange') 
            fig5.ax1.plot(time[tr_1:tr_2], func(np.concatenate((pout[1], pout[2:, :2].flatten())), time)[tr_1:tr_2], color = 'red')#!!!
            fig5.ax1.autoscale()
            fig5.ax1.set(xlim = np.flip(ybd), ylim = (0.9*min(decay), 1.1*max(decay)))
            #Residuals.
            fig5.ax2.lines.clear()
            fig5.ax2.plot(time[tr_1:tr_2], res.fun, color = 'green') 
            fig5.ax2.autoscale()
            fig5.ax2.relim()
            fig5.ax2.set(xlim = np.flip(ybd))
        
            fig5.tb.update()
            fig5.fig.canvas.draw()
    #%%exp   
        if event == '-EXP_MASTER-':
            for key in exp_names.keys():
                path = values[event] + "/" + os.path.splitext(values['-OPEN_FILE-'])[0].split('/')[-1]
                values[key] = path + exp_names[key] + ".txt"
        try:
            if event in {'-EXP_MASTER-', '-EXP_IMG-'}:
                exp_x = np.insert(ars(xcal), 0 , "N/a")
                exp_data = np.column_stack((ars(ylin), img))
                np.savetxt(values['-EXP_IMG-'], np.vstack((exp_x, exp_data)), "%s", '\t')
        except FileNotFoundError:
            pass
        except (NameError, ValueError, IndexError):
            if event != '-EXP_MASTER-' and values[event] != '':
                sg.popup("No data to export.", title = "Error")
        try:
            if event in {'-EXP_MASTER-', '-EXP_SPECTRA-'}:
                exp_data = np.column_stack((ars(xcal), ars(fin_spe, 3)))
                exp_data = np.vstack((['Wavelengh, nm'] + spe_names, exp_data))
                np.savetxt(values['-EXP_SPECTRA-'], exp_data, "%s", '\t')
        except FileNotFoundError:
            pass
        except (NameError, ValueError, IndexError):
            if event != '-EXP_MASTER-' and values[event] != '':
                sg.popup("No data to export.", title = "Error")
        try:
            if event in {'-EXP_MASTER-', '-EXP_DEC-'}:
                exp_data = []
                exp_title = []
                for c in range(len(all_dec)):
                    exp_data.append(ylin + dec_shift[c])
                    exp_data.append(all_dec[c])
                    exp_title.append('t, ' + time_unit)
                    exp_title.append(dec_names[c])
                exp_data = np.vstack((exp_title, ars(exp_data)))
                np.savetxt(values['-EXP_DEC-'], exp_data, "%s", '\t')
        except FileNotFoundError:
            pass
        except (NameError, ValueError, IndexError):
            if event != '-EXP_MASTER-' and values[event] != '':
                sg.popup("No data to export.", title = "Error")
        try:
            if event in {'-EXP_MASTER-', '-EXP_FIT-'}:
                par_vals = ["%.3E" %(a) for a in pout.flatten()]
                par_names = ["Chi^2", "tA", "tI", "Width", "Position", "Background", "t1", "A1", "A1%", "t2", "A2", "A2%", "t3", "A3", "A3%"]            
                exp_data = np.column_stack((par_names[:len(par_vals)], par_vals))
                np.savetxt(values['-EXP_FIT-'], exp_data, "%s", '\t')
        except FileNotFoundError:
            pass
        except (NameError, ValueError, IndexError):
            if event != '-EXP_MASTER-' and values[event] != '':
                sg.popup("No data to export.", title = "Error")
        wincl(tuple(exp_names.keys()))

    window.close()
except:
    err = np.array(event_history + [traceback.format_exc()])
    np.savetxt(os.path.abspath(os.getcwd()) + "\crash_log.txt", err, "%s", "\t")
try: 
    file_bin.close()
except: 
    pass

#sys.modules[__name__].__dict__.clear()
